package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

var (
	headerTemplate = `// Code generated by gomutate; DO NOT EDIT.
package {{.PackageName}}

import (
	{{range .Imports}}"{{.}}"
	{{end}}
)
`
	mainMutatorTemplate = `
type Mutator{{.TypeName}} struct {
	inner   *{{.TypeName}}
	changes ChangeLogger
}

func NewMutator{{.TypeName}}(obj *{{.TypeName}}) *Mutator{{.TypeName}} {
	return &Mutator{{.TypeName}}{
		inner:   obj,
		changes: NewDefaultChangeLogger(""),
	}
}

// FormatChanges returns the changes that were made to the object as strings
func (m *Mutator{{.TypeName}}) FormatChanges() []string {
	return m.changes.ToString()
}
`

	subMutatorTemplate = `
type Mutator{{.TypeName}} struct {
	inner   *{{.TypeName}}
	changes ChangeLogger
}

func NewMutator{{.TypeName}}(obj *{{.TypeName}}, changes ChangeLogger) *Mutator{{.TypeName}} {
	return &Mutator{{.TypeName}}{
		inner:   obj,
		changes: changes,
	}
}
`

	mutateFieldTemplate = `
// Mutate{{.FieldName}} mutates the {{.FieldName}} of the {{.TypeName}} object
func (m *Mutator{{.TypeName}}) Mutate{{.FieldName}}(value {{.FieldTypeName}}) bool {
	if m.inner.{{.FieldName}} == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "{{.FieldName}}",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.{{.FieldName}}),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.{{.FieldName}} = value

	return true
}
`

	mapOrSliceSetTemplate = `
// Set{{.FieldName}} sets {{.FieldName}} of the {{.TypeName}} object
func (m *Mutator{{.TypeName}}) Set{{.FieldName}}(value {{.FieldTypeName}}) bool {

	if len(value) == 0 && len(m.inner.{{.FieldName}}) == 0 {
		return false
	}

	operation := ChangeOperationSet
	if len(value) == 0 {
		operation = ChangeOperationClear
	}

	m.changes.Append(Change{
		FieldName: "{{.FieldName}}",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.{{.FieldName}}),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.{{.FieldName}} = value

	return true
}
`

	mapInsertTemplate = `
// Insert{{.FieldName}} inserts a {{.FieldName}} map element of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Insert{{.FieldName}}(
	key {{if .FieldKeyTypeIsPointer}}*{{end}}{{.FieldKeyTypeName}},
	value {{if .FieldTypeIsPointer}}*{{end}}{{.FieldTypeName}},
) bool {
	currentValue, exists := m.inner.{{.FieldName}}[key]
	if exists && currentValue == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "{{.FieldName}}",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("with key '%+v' and value: %+v", key, value),
	})

	if m.inner.{{.FieldName}} == nil {
		m.inner.{{.FieldName}} = make(map[{{if .FieldKeyTypeIsPointer}}*{{end}}{{.FieldKeyTypeName}}]{{if .FieldTypeIsPointer}}*{{end}}{{.FieldTypeName}})
	}

	m.inner.{{.FieldName}}[key] = value

	return true
}

// Remove{{.FieldName}} removes a {{.FieldName}} map element of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Remove{{.FieldName}}(key {{if .FieldKeyTypeIsPointer}}*{{end}}{{.FieldKeyTypeName}}) bool {
	_, exists := m.inner.{{.FieldName}}[key]
	if !exists {
		return false
	}

	m.changes.Append(Change{
		FieldName: "{{.FieldName}}",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("with key '%+v' and value: %+v", key, m.inner.{{.FieldName}}[key]),
	})
	delete(m.inner.{{.FieldName}}, key)

	return true
}
`

	sliceAppendTemplate = `
// Append{{.FieldName}} appends a {{.FieldName}} element of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Append{{.FieldName}}(value ...{{if .FieldTypeIsPointer}}*{{end}}{{.FieldTypeName}}) {
	m.changes.Append(Change{
		FieldName: "{{.FieldName}}",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.{{.FieldName}} = append(m.inner.{{.FieldName}}, value...)
}

// Remove{{.FieldName}} removes a {{.FieldName}} element of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Remove{{.FieldName}}(index int) {
	m.changes.Append(Change{
		FieldName: "{{.FieldName}}",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.{{.FieldName}}[index]),
	})
	m.inner.{{.FieldName}} = append(m.inner.{{.FieldName}}[:index], m.inner.{{.FieldName}}[index+1:]...)
}
`

	mutateSetObjTemplate = `
// Set{{.FieldName}} sets {{.FieldName}} of the {{.TypeName}} object
func (m *Mutator{{.TypeName}}) Set{{.FieldName}}(value *{{.FieldTypeName}}) bool {

	m.changes.Append(Change{
		FieldName: "{{.FieldName}}",
		Operation: ChangeOperationSet,
		OldValue:  fmt.Sprintf("%+v", m.inner.{{.FieldName}}),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.{{.FieldName}} = *value

	return true
}
`

	mutateSetPtrTemplate = `
// Set{{.FieldName}} sets {{.FieldName}} of the {{.TypeName}} object
func (m *Mutator{{.TypeName}}) Set{{.FieldName}}(value {{.FieldTypeName}}) bool {

	if value == nil && m.inner.{{.FieldName}} == nil {
		return false
	}

	if value == m.inner.{{.FieldName}} {
		return false
	}

	operation := ChangeOperationClear
	valueStr := fmt.Sprintf("%+v", value)
	oldValueStr := fmt.Sprintf("%+v", m.inner.{{.FieldName}})

	if value != nil {
		operation = ChangeOperationSet
		valueStr = fmt.Sprintf("%+v", *value)
	}

	if m.inner.{{.FieldName}} != nil {
		oldValueStr = fmt.Sprintf("%+v", *m.inner.{{.FieldName}})
	}

	m.changes.Append(Change{
		FieldName: "{{.FieldName}}",
		Operation: operation,
		OldValue:  oldValueStr,
		NewValue:  valueStr,
	})
	m.inner.{{.FieldName}} = value

	return true
}
`

	mutatePtrTemplate = `
// Mutate{{.FieldName}} returns a mutator for {{.FieldName}} of the {{.TypeName}} object.
// If the field is nil, it will be initialized to a new {{.FieldTypeName}} object.
func (m *Mutator{{.TypeName}}) Mutate{{.FieldName}}() *Mutator{{.FieldTypeName}} {

	if m.inner.{{.FieldName}} == nil {
		m.inner.{{.FieldName}} = &{{.FieldTypeName}}{}
	}

	return NewMutator{{.FieldTypeName}}(m.inner.{{.FieldName}}, NewChainedChangeLogger(fmt.Sprintf("{{.FieldName}} "), m.changes))
}
`

	mutateSliceElementTemplate = `
// Mutate{{.FieldName}}At returns a mutator for {{.FieldName}} element at index of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Mutate{{.FieldName}}At(index int) *Mutator{{.FieldTypeName}} {
	return NewMutator{{.FieldTypeName}}({{if .FieldTypeIsPointer}}{{else}}&{{end}}m.inner.{{.FieldName}}[index], NewChainedChangeLogger(fmt.Sprintf("{{.FieldName}} "), m.changes))
}
`

	mutateObjTemplate = `
// Mutate{{.FieldName}} returns a mutator for {{.FieldName}} of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Mutate{{.FieldName}}() *Mutator{{.FieldTypeName}} {

	return NewMutator{{.FieldTypeName}}(&m.inner.{{.FieldName}}, NewChainedChangeLogger("{{.FieldName}} ", m.changes))
}
`

	mutateMapElementTemplate = `
// Mutate{{.FieldName}}WithKey returns a mutator for {{.FieldName}} map element {{.TypeName}} object with given key.
func (m *Mutator{{.TypeName}}) Mutate{{.FieldName}}WithKey(key {{.FieldKeyTypeName}}) *Mutator{{.FieldTypeName}} {
	return NewMutator{{.FieldTypeName}}(
		{{if .FieldTypeIsPointer}}{{else}}&{{end}}m.inner.{{.FieldName}}[key],
		NewChainedChangeLogger(fmt.Sprintf("{{.FieldName}} "), m.changes),
	)
}
`
)

type templateStep struct {
	template string
	data     interface{}
}

type headerData struct {
	PackageName string
	Imports     []string
}

type mutatorData struct {
	TypeName string
}

type mutateFunctionData struct {
	TypeName              string
	FieldName             string
	FieldKeyTypeName      string
	FieldTypeName         string
	FieldTypeIsPointer    bool
	FieldKeyTypeIsPointer bool
}

func Usage() {
	_, _ = fmt.Fprintf(os.Stderr, "gomutate generates Go code to mutate a Go type.\n")
	_, _ = fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	_, _ = fmt.Fprintf(os.Stderr, "\tgomutate [flags] -type Type <file.go>...\n")
	_, _ = fmt.Fprintf(os.Stderr, "\nall files must be in the same directory\n\n")
	_, _ = fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

var (
	flagType = flag.String("type", "", "type to generate code for (required)")
)

func main() {
	log.SetPrefix("gomutate: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*flagType) == 0 {
		flag.Usage()
		os.Exit(1)
	}

	if len(flag.Args()) == 0 {
		fmt.Fprintf(os.Stderr, "Specify at least one go file\n")
		flag.Usage()
		os.Exit(1)
	}

	// get directory of all files
	filenames := flag.Args()

	directory := path.Dir(filenames[0])
	for _, filename := range filenames {
		if path.Dir(filename) != directory {
			fmt.Fprintf(os.Stderr, "All files must be in the same directory\n")
			flag.Usage()
			os.Exit(1)
		}
	}

	loadAllSyntax := packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles | packages.NeedImports | packages.NeedTypes | packages.NeedTypesSizes | packages.NeedSyntax | packages.NeedTypesInfo

	cfg := &packages.Config{
		Mode:  loadAllSyntax,
		Tests: false,
		Dir:   directory,
	}
	pkgs, err := packages.Load(cfg, "")
	if err != nil {
		log.Fatal(err)
	}

	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found, expected 1", len(pkgs))
	}

	pkg := pkgs[0]
	packageName := pkg.Name

	fset := token.NewFileSet()

	targetTypeName := *flagType

	// gather all struct declarations
	var typeSpecs []ast.Node

	var mainDecl *ast.TypeSpec

	exprTypeMap := make(map[ast.Expr]types.TypeAndValue)

	for _, filename := range pkg.GoFiles {
		if !isSelectedFilename(filename, filenames) {
			continue
		}

		node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
		if err != nil {
			log.Fatalf("failed to parse file %s: %s", filename, err)
		}

		info := types.Info{Types: make(map[ast.Expr]types.TypeAndValue)}
		_, err = (&types.Config{Importer: importer.Default()}).Check(packageName, fset, []*ast.File{node}, &info)
		if err != nil {
			log.Fatal(err)
		}

		// merge onto exprTypeMap
		for expr, typeAndValue := range info.Types {
			exprTypeMap[expr] = typeAndValue
		}

		ast.Inspect(node, func(n ast.Node) bool {
			tspec, isTypeSpec := n.(*ast.TypeSpec)
			if !isTypeSpec {
				return true
			}

			if tspec.Name.Name == targetTypeName {
				mainDecl = tspec
			}

			_, isStructDecl := tspec.Type.(*ast.StructType)
			if !isStructDecl {
				return true
			}

			typeSpecs = append(typeSpecs, n)
			return true
		})
	}

	mainMutator := mutatorData{
		TypeName: mainDecl.Name.Name,
	}

	var otherMutators []mutatorData

	for _, node := range typeSpecs {
		spec := node.(*ast.TypeSpec)
		if spec.Name.Name == targetTypeName {
			continue
		}

		otherMutators = append(otherMutators, mutatorData{
			TypeName: spec.Name.Name,
		})
	}

	header := headerData{
		PackageName: packageName,
		Imports:     []string{"fmt", "time"},
	}

	templateSteps := []templateStep{
		{
			template: headerTemplate,
			data:     header,
		}, {
			template: mainMutatorTemplate,
			data:     mainMutator,
		},
	}

	for i := range otherMutators {
		templateSteps = append(templateSteps, templateStep{
			template: subMutatorTemplate,
			data:     otherMutators[i],
		})
	}

	templateSteps = handleStructType(templateSteps, packageName, mainDecl, exprTypeMap, typeSpecs, make(map[string]bool))

	for i, step := range templateSteps {
		tmpl, err := template.New(fmt.Sprintf("template%d", i)).Parse(step.template)
		if err != nil {
			log.Fatal(err)
		}

		err = tmpl.Execute(os.Stdout, step.data)
		if err != nil {
			log.Fatal(err)
		}
	}
}

func handleStructType(
	steps []templateStep,
	packageName string,
	structSpec *ast.TypeSpec,
	typesInfo map[ast.Expr]types.TypeAndValue,
	typeSpecs []ast.Node,
	handledTypes map[string]bool,
) []templateStep {
	_, exists := handledTypes[structSpec.Name.Name]
	if exists {
		return steps
	}

	handledTypes[structSpec.Name.Name] = true

	structType := structSpec.Type.(*ast.StructType)

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		fieldType := typesInfo[field.Type].Type

		locallyDefined := false

		trimmedTypeStr := trimAllPrefixes(fieldType.String(), packageName)
		for _, spec := range typeSpecs {
			if spec.(*ast.TypeSpec).Name.Name == trimmedTypeStr {
				steps = handleStructType(steps, packageName, spec.(*ast.TypeSpec), typesInfo, typeSpecs, handledTypes)
				locallyDefined = true
			}
		}

		var toAppend []templateStep

		switch fieldType.(type) {
		case *types.Slice:
			toAppend = handleSlice(packageName, structSpec, field, fieldType, locallyDefined)
		case *types.Map:
			toAppend = handleMap(packageName, structSpec, field, fieldType, locallyDefined)
		case *types.Pointer:
			toAppend = handlePointer(packageName, structSpec, field, fieldType, locallyDefined)
		default:
			if locallyDefined { // may be a struct non-pointer type
				toAppend = handleObject(packageName, structSpec, field, fieldType, locallyDefined)
			} else {
				toAppend = handleOther(packageName, structSpec, field, fieldType, locallyDefined)
			}
		}

		steps = append(steps, toAppend...)
	}

	return steps
}

func handleSlice(
	packageName string,
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
) []templateStep {
	_, fieldTypeIsPointer := fieldType.(*types.Slice).Elem().Underlying().(*types.Pointer)

	steps := []templateStep{
		{
			template: mapOrSliceSetTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), packageName),
			},
		},
		{
			template: sliceAppendTemplate,
			data: mutateFunctionData{
				TypeName:           structSpec.Name.Name,
				FieldName:          field.Names[0].Name,
				FieldTypeName:      trimAllPrefixes(fieldType.String(), packageName),
				FieldTypeIsPointer: fieldTypeIsPointer,
			},
		},
	}

	if !locallyDefined {
		return steps
	}

	return append(steps, templateStep{
		template: mutateSliceElementTemplate,
		data: mutateFunctionData{
			TypeName:           structSpec.Name.Name,
			FieldName:          field.Names[0].Name,
			FieldTypeName:      trimAllPrefixes(fieldType.String(), packageName),
			FieldTypeIsPointer: fieldTypeIsPointer,
		},
	})
}

func handleMap(
	packageName string,
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
) []templateStep {
	_, fieldTypeIsPointer := fieldType.(*types.Map).Elem().Underlying().(*types.Pointer)

	fieldKeyType := fieldType.(*types.Map).Key()
	_, fieldKeyTypeIsPointer := fieldKeyType.Underlying().(*types.Pointer)

	steps := []templateStep{
		{
			template: mapOrSliceSetTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), packageName),
			},
		},
		{
			template: mapInsertTemplate,
			data: mutateFunctionData{
				TypeName:              structSpec.Name.Name,
				FieldName:             field.Names[0].Name,
				FieldKeyTypeName:      trimAllPrefixes(fieldKeyType.String(), packageName),
				FieldTypeName:         trimAllPrefixes(fieldType.String(), packageName),
				FieldTypeIsPointer:    fieldTypeIsPointer,
				FieldKeyTypeIsPointer: fieldKeyTypeIsPointer,
			},
		},
	}

	if !locallyDefined {
		return steps
	}

	return append(steps, templateStep{
		template: mutateMapElementTemplate,
		data: mutateFunctionData{
			TypeName:           structSpec.Name.Name,
			FieldName:          field.Names[0].Name,
			FieldKeyTypeName:   trimAllPrefixes(fieldKeyType.String(), packageName),
			FieldTypeName:      trimAllPrefixes(fieldType.String(), packageName),
			FieldTypeIsPointer: fieldTypeIsPointer,
		},
	})
}

func handlePointer(
	packageName string,
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
) []templateStep {
	steps := []templateStep{
		{
			template: mutateSetPtrTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), packageName),
			},
		},
	}

	if !locallyDefined {
		return steps
	}

	return append(steps, templateStep{
		template: mutatePtrTemplate,
		data: mutateFunctionData{
			TypeName:      structSpec.Name.Name,
			FieldName:     field.Names[0].Name,
			FieldTypeName: trimAllPrefixes(fieldType.String(), packageName),
		},
	})
}

func handleObject(
	packageName string,
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
) []templateStep {
	steps := []templateStep{
		{
			template: mutateSetObjTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), packageName),
			},
		},
	}

	if !locallyDefined {
		return steps
	}

	return append(steps, templateStep{
		template: mutateObjTemplate,
		data: mutateFunctionData{
			TypeName:      structSpec.Name.Name,
			FieldName:     field.Names[0].Name,
			FieldTypeName: trimAllPrefixes(fieldType.String(), packageName),
		},
	})
}

func handleOther(
	packageName string,
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
) []templateStep {
	return []templateStep{
		{
			template: mutateFieldTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), packageName),
			},
		},
	}
}

func isSelectedFilename(file string, list []string) bool {
	for _, item := range list {
		itemPath, err := filepath.Abs(item)
		if err != nil {
			continue
		}

		filePath, err := filepath.Abs(file)
		if err != nil {
			continue
		}

		if filePath == itemPath {
			return true
		}
	}

	return false
}

func trimPackagePrefix(input, packageName string) string {
	pattern := `(^|\[|\*|\])` + packageName + `\.`

	regex := regexp.MustCompile(pattern)

	return regex.ReplaceAllString(input, "$1")
}

func trimAllPrefixes(typeName string, pkg string) string {
	start := strings.LastIndexAny(typeName, "[]*")
	if start == -1 {
		start = 0
	} else {
		start++
	}

	dot := strings.LastIndex(typeName, ".")
	if dot == -1 || dot <= start {
		return typeName[start:]
	}

	if typeName[start:dot] == pkg {
		return typeName[dot+1:]
	}

	return typeName
}
