package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

var (
	headerTemplate = `// Code generated by gomutate; DO NOT EDIT.
package {{.PackageName}}

import (
	{{range .Imports}}"{{.}}"
	{{end}}
)
`

	fieldNamesTemplate string = `
{{with .}}
const ({{range .}}
	{{.ConstName}} changes.FieldName = "{{.ConstValue}}"{{end}}
){{end}}
`

	mainMutatorTemplate = `
// Mutator{{.TypeName}} mutates the {{.TypeName}} object.
type Mutator{{.TypeName}} struct {
	inner   *{{.TypeName}}
	changes changes.Logger
}

// NewMutator{{.TypeName}} creates a new mutator for the {{.TypeName}} object.
func NewMutator{{.TypeName}}(
	obj *{{.TypeName}},
	options ...func(*Mutator{{.TypeName}}),
) *Mutator{{.TypeName}} {
	m := &Mutator{{.TypeName}}{
		inner:   obj,
		changes: changes.NewDefaultLogger(changes.PrefixEmpty),
	}

	for _, option := range options {
		option(m)
	}

	return m
}

// WithChangeLogger sets the change logger for the mutator.
func WithChangeLogger(logger changes.Logger) func(*Mutator{{.TypeName}}) {
	return func(m *Mutator{{.TypeName}}) {
		m.changes = logger
	}
}

// FormatChanges returns the changes that were made to the object as strings
func (m *Mutator{{.TypeName}}) FormatChanges() []string {
	return m.changes.ToString()
}
`

	subMutatorTemplate = `
type Mutator{{.TypeName}} struct {
	inner   *{{.TypeName}}
	changes changes.Logger
}

func NewMutator{{.TypeName}}(obj *{{.TypeName}}, changes changes.Logger) *Mutator{{.TypeName}} {
	return &Mutator{{.TypeName}}{
		inner:   obj,
		changes: changes,
	}
}
`

	mutateFieldTemplate = `
// Set{{.FieldName}} mutates the {{.FieldName}} of the {{.TypeName}} object
func (m *Mutator{{.TypeName}}) Set{{.FieldName}}(value {{.FieldTypeName}}) bool {
	if m.inner.{{.FieldName}} == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.{{.FieldName}}).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "{{.FieldName}}",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.{{.FieldName}}),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.{{.FieldName}} = value

	return true
}
`

	mapOrSliceSetTemplate = `
// Set{{.FieldName}} sets {{.FieldName}} of the {{.TypeName}} object
func (m *Mutator{{.TypeName}}) Set{{.FieldName}}(value {{.FieldTypeName}}) bool {

	if len(value) == 0 && len(m.inner.{{.FieldName}}) == 0 {
		return false
	}

	operation := changes.OperationSet
	if len(value) == 0 {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "{{.FieldName}}",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.{{.FieldName}}),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.{{.FieldName}} = value

	return true
}
`

	mapInsertTemplate = `
// Insert{{.FieldName}} inserts a {{.FieldName}} map element of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Insert{{.FieldName}}(
	key {{if .FieldKeyTypeIsPointer}}*{{end}}{{.FieldKeyTypeName}},
	value {{if .FieldTypeIsPointer}}*{{end}}{{.FieldTypeName}},
) bool {
	currentValue, exists := m.inner.{{.FieldName}}[key]
	if exists && currentValue == value {
		return false
	}

	m.changes.Append(changes.Change{
		FieldName: "{{.FieldName}}",
		Operation: changes.OperationAdded,
		Key:       changes.IntoKey(key),
		NewValue:  fmt.Sprintf("%+v", value),
	})

	if m.inner.{{.FieldName}} == nil {
		m.inner.{{.FieldName}} = make(map[{{if .FieldKeyTypeIsPointer}}*{{end}}{{.FieldKeyTypeName}}]{{if .FieldTypeIsPointer}}*{{end}}{{.FieldTypeName}})
	}

	m.inner.{{.FieldName}}[key] = value

	return true
}

// Remove{{.FieldName}} removes a {{.FieldName}} map element of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Remove{{.FieldName}}(key {{if .FieldKeyTypeIsPointer}}*{{end}}{{.FieldKeyTypeName}}) bool {
	_, exists := m.inner.{{.FieldName}}[key]
	if !exists {
		return false
	}

	m.changes.Append(changes.Change{
		FieldName: "{{.FieldName}}",
		Operation: changes.OperationRemoved,
		Key:       changes.IntoKey(key),
		OldValue:  fmt.Sprintf("%+v", m.inner.{{.FieldName}}[key]),
	})
	delete(m.inner.{{.FieldName}}, key)

	return true
}
`

	sliceAppendTemplate = `
// Append{{.FieldName}} appends a {{.FieldName}} element of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Append{{.FieldName}}(value ...{{if .FieldTypeIsPointer}}*{{end}}{{.FieldTypeName}}) {
	var appended any = value
	if len(value) == 1 {
		appended = value[0]
	}

	m.changes.Append(changes.Change{
		FieldName: "{{.FieldName}}",
		Operation: changes.OperationAdded,
		NewValue:  fmt.Sprintf("%+v", appended),
	})
	m.inner.{{.FieldName}} = append(m.inner.{{.FieldName}}, value...)
}

// Remove{{.FieldName}} removes a {{.FieldName}} element of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) Remove{{.FieldName}}(index int) {
	m.changes.Append(changes.Change{
		FieldName: "{{.FieldName}}",
		Operation: changes.OperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.{{.FieldName}}[index]),
	})
	m.inner.{{.FieldName}} = append(m.inner.{{.FieldName}}[:index], m.inner.{{.FieldName}}[index+1:]...)
}
`

	mutateSetObjTemplate = `
// Set{{.FieldName}} sets {{.FieldName}} of the {{.TypeName}} object
func (m *Mutator{{.TypeName}}) Set{{.FieldName}}(value *{{.FieldTypeName}}) bool {

	m.changes.Append(changes.Change{
		FieldName: "{{.FieldName}}",
		Operation: changes.OperationSet,
		OldValue:  fmt.Sprintf("%+v", m.inner.{{.FieldName}}),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.{{.FieldName}} = *value

	return true
}
`

	mutateSetPtrTemplate = `
// Set{{.FieldName}} sets {{.FieldName}} of the {{.TypeName}} object
func (m *Mutator{{.TypeName}}) Set{{.FieldName}}(value {{.FieldTypeName}}) bool {

	if value == nil && m.inner.{{.FieldName}} == nil {
		return false
	}

	if value == m.inner.{{.FieldName}} {
		return false
	}

	operation := changes.OperationCleared
	valueStr := fmt.Sprintf("%+v", value)
	oldValueStr := fmt.Sprintf("%+v", m.inner.{{.FieldName}})

	if value != nil {
		operation = changes.OperationSet
		valueStr = fmt.Sprintf("%+v", *value)
	}

	if m.inner.{{.FieldName}} != nil {
		oldValueStr = fmt.Sprintf("%+v", *m.inner.{{.FieldName}})
	}

	m.changes.Append(changes.Change{
		FieldName: "{{.FieldName}}",
		Operation: operation,
		OldValue:  oldValueStr,
		NewValue:  valueStr,
	})
	m.inner.{{.FieldName}} = value

	return true
}
`

	mutatePtrTemplate = `
// {{.FieldName}} returns a mutator for {{.FieldName}} of the {{.TypeName}} object.
// If the field is nil, it will be initialized to a new {{.FieldTypeName}} object.
func (m *Mutator{{.TypeName}}) {{.FieldName}}() *Mutator{{.FieldTypeName}} {

	if m.inner.{{.FieldName}} == nil {
		m.inner.{{.FieldName}} = &{{.FieldTypeName}}{}
	}

	prefix := changes.NewPrefix(MutationPrefix{{.Prefix}})

	return NewMutator{{.FieldTypeName}}(m.inner.{{.FieldName}}, changes.NewChainedLogger(prefix, m.changes))
}
`

	mutateSliceElementTemplate = `
// {{.FieldName}}At returns a mutator for {{.FieldName}} element at index of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) {{.FieldName}}At(index int) *Mutator{{.FieldTypeName}} {
	object := {{if .FieldTypeIsPointer}}{{else}}&{{end}}m.inner.{{.FieldName}}[index]

	prefix := changes.NewPrefixWithKey(MutationPrefix{{.Prefix}}, changes.IntoKey(object))

	return NewMutator{{.FieldTypeName}}(
		object,
		changes.NewChainedLogger(prefix, m.changes),
	)
}
{{if .FieldTypeIsPointer}}
// {{.FieldName}}ByPtr returns a mutator for {{.FieldName}} element given by a pointer of type {{.TypeName}}.
func (m *Mutator{{.TypeName}}) {{.FieldName}}ByPtr(ptr *{{.FieldTypeName}}) *Mutator{{.FieldTypeName}} {
	for i, item := range m.inner.{{.FieldName}} {
		if item == ptr {
			return m.{{.FieldName}}At(i)
		}
	}
	return nil
}{{end}}
`

	mutateObjTemplate = `
// {{.FieldName}} returns a mutator for {{.FieldName}} of the {{.TypeName}} object.
func (m *Mutator{{.TypeName}}) {{.FieldName}}() *Mutator{{.FieldTypeName}} {
	prefix := changes.NewPrefix(MutationPrefix{{.Prefix}})
	return NewMutator{{.FieldTypeName}}(&m.inner.{{.FieldName}}, changes.NewChainedLogger(prefix, m.changes))
}
`

	mutateMapElementTemplate = `
// {{.FieldName}}WithKey returns a mutator for {{.FieldName}} map element {{.TypeName}} object with given key.
func (m *Mutator{{.TypeName}}) {{.FieldName}}WithKey(key {{.FieldKeyTypeName}}) *Mutator{{.FieldTypeName}} {
	object := {{if .FieldTypeIsPointer}}{{else}}&{{end}}m.inner.{{.FieldName}}[key]

	prefix := changes.NewPrefixWithKey(MutationPrefix{{.Prefix}}, changes.IntoKey(object))

	return NewMutator{{.FieldTypeName}}(
		object,
		changes.NewChainedLogger(prefix, m.changes),
	)
}
`
)

type templateStep struct {
	template string
	data     interface{}
}

type headerData struct {
	PackageName string
	Imports     []string
}

type mutatorData struct {
	TypeName string
}

type mutateFunctionData struct {
	TypeName              string
	FieldName             string
	FieldKeyTypeName      string
	FieldTypeName         string
	FieldTypeIsPointer    bool
	FieldKeyTypeIsPointer bool
	Prefix                string
}

type prefixData struct {
	ConstName  string
	ConstValue string
}

func Usage() {
	_, _ = fmt.Fprintf(os.Stderr, "gomutate generates Go code to mutate a Go type.\n")
	_, _ = fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	_, _ = fmt.Fprintf(os.Stderr, "\tgomutate [flags] -type Type <file.go>...\n")
	_, _ = fmt.Fprintf(os.Stderr, "\nall files must be in the same directory\n\n")
	_, _ = fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

var (
	flagType  = flag.String("type", "", "type to generate code for (required)")
	flagWrite = flag.String("w", "", "write result to a file instead of stdout")
)

func main() {
	log.SetPrefix("gomutate: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*flagType) == 0 {
		flag.Usage()
		os.Exit(1)
	}

	if len(flag.Args()) == 0 {
		fmt.Fprintf(os.Stderr, "Specify at least one go file\n")
		flag.Usage()
		os.Exit(1)
	}

	// get directory of all files
	filenames := flag.Args()

	directory := path.Dir(filenames[0])
	for _, filename := range filenames {
		if path.Dir(filename) != directory {
			fmt.Fprintf(os.Stderr, "All files must be in the same directory\n")
			flag.Usage()
			os.Exit(1)
		}
	}

	loadAllSyntax := packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles | packages.NeedImports | packages.NeedTypes | packages.NeedTypesSizes | packages.NeedSyntax | packages.NeedTypesInfo

	cfg := &packages.Config{
		Mode:  loadAllSyntax,
		Tests: false,
		Dir:   directory,
	}
	pkgs, err := packages.Load(cfg, "")
	if err != nil {
		log.Fatal(err)
	}

	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found, expected 1", len(pkgs))
	}

	pkg := pkgs[0]
	packageName := pkg.Name

	fset := token.NewFileSet()

	targetTypeName := *flagType
	var output io.Writer = os.Stdout
	if *flagWrite != "" {
		output, err = os.Create(*flagWrite)
		if err != nil {
			log.Fatal(err)
		}
	}

	// gather all struct declarations
	var typeSpecs []ast.Node

	var mainDecl *ast.TypeSpec

	exprTypeMap := make(map[ast.Expr]types.TypeAndValue)

	for _, filename := range pkg.GoFiles {
		if !isSelectedFilename(filename, filenames) {
			continue
		}

		node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
		if err != nil {
			log.Fatalf("failed to parse file %s: %s", filename, err)
		}

		info := types.Info{Types: make(map[ast.Expr]types.TypeAndValue)}
		_, err = (&types.Config{Importer: importer.Default()}).Check(packageName, fset, []*ast.File{node}, &info)
		if err != nil {
			log.Fatal(err)
		}

		// merge onto exprTypeMap
		for expr, typeAndValue := range info.Types {
			exprTypeMap[expr] = typeAndValue
		}

		ast.Inspect(node, func(n ast.Node) bool {
			tspec, isTypeSpec := n.(*ast.TypeSpec)
			if !isTypeSpec {
				return true
			}

			if tspec.Name.Name == targetTypeName {
				mainDecl = tspec
			}

			_, isStructDecl := tspec.Type.(*ast.StructType)
			if !isStructDecl {
				return true
			}

			typeSpecs = append(typeSpecs, n)
			return true
		})
	}

	mainMutator := mutatorData{
		TypeName: mainDecl.Name.Name,
	}

	var otherMutators []mutatorData

	for _, node := range typeSpecs {
		spec := node.(*ast.TypeSpec)
		if spec.Name.Name == targetTypeName {
			continue
		}

		otherMutators = append(otherMutators, mutatorData{
			TypeName: spec.Name.Name,
		})
	}

	header := headerData{
		PackageName: packageName,
		Imports:     []string{"fmt", "time", "reflect", "github.com/pdcalado/gomutate/changes"},
	}

	templateSteps := []templateStep{
		{
			template: headerTemplate,
			data:     header,
		}, {
			template: mainMutatorTemplate,
			data:     mainMutator,
		},
	}

	for i := range otherMutators {
		templateSteps = append(templateSteps, templateStep{
			template: subMutatorTemplate,
			data:     otherMutators[i],
		})
	}

	handler := newHandler(packageName, exprTypeMap, typeSpecs)

	templateSteps = append(templateSteps, handler.handle(mainDecl)...)

	for i, step := range templateSteps {
		tmpl, err := template.New(fmt.Sprintf("template%d", i)).Parse(step.template)
		if err != nil {
			log.Fatal(err)
		}

		err = tmpl.Execute(output, step.data)
		if err != nil {
			log.Fatal(err)
		}
	}
}

type handler struct {
	packageName  string
	typesInfo    map[ast.Expr]types.TypeAndValue
	typeSpecs    []ast.Node
	handledTypes map[string]bool
	prefixes     map[string]string
}

func newHandler(
	packageName string,
	typesInfo map[ast.Expr]types.TypeAndValue,
	typeSpecs []ast.Node,
) *handler {
	return &handler{
		packageName:  packageName,
		typesInfo:    typesInfo,
		typeSpecs:    typeSpecs,
		handledTypes: make(map[string]bool),
		prefixes:     make(map[string]string),
	}
}

// handle may only be called once
func (h *handler) handle(structSpec *ast.TypeSpec) []templateStep {
	steps := h.handleStructType(structSpec, []templateStep{}, "")

	prefixes := make([]prefixData, 0, len(h.prefixes))
	for name, value := range h.prefixes {
		prefixes = append(prefixes, prefixData{
			ConstName:  fmt.Sprintf("MutationPrefix%s", name),
			ConstValue: value,
		})
	}
	sort.SliceStable(prefixes, func(i, j int) bool {
		return prefixes[i].ConstName < prefixes[j].ConstName
	})

	return append([]templateStep{
		{
			template: fieldNamesTemplate,
			data:     prefixes,
		},
	}, steps...)
}

func (h *handler) handleStructType(
	structSpec *ast.TypeSpec,
	steps []templateStep,
	prefix string,
) []templateStep {
	_, exists := h.handledTypes[structSpec.Name.Name]
	if exists {
		return steps
	}

	h.handledTypes[structSpec.Name.Name] = true

	structType := structSpec.Type.(*ast.StructType)

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		fieldPrefix := prefix

		fieldType := h.typesInfo[field.Type].Type

		locallyDefined := false

		trimmedTypeStr := trimAllPrefixes(fieldType.String(), h.packageName)
		for _, spec := range h.typeSpecs {
			if spec.(*ast.TypeSpec).Name.Name == trimmedTypeStr {
				fieldPrefix = fieldPrefix + field.Names[0].Name
				locallyDefined = true
				h.prefixes[fieldPrefix] = field.Names[0].Name

				steps = h.handleStructType(spec.(*ast.TypeSpec), steps, fieldPrefix)
			}
		}

		var toAppend []templateStep

		switch fieldType.(type) {
		case *types.Slice:
			toAppend = h.handleSlice(structSpec, field, fieldType, locallyDefined, fieldPrefix)
		case *types.Map:
			toAppend = h.handleMap(structSpec, field, fieldType, locallyDefined, fieldPrefix)
		case *types.Pointer:
			toAppend = h.handlePointer(structSpec, field, fieldType, locallyDefined, fieldPrefix)
		default:
			if locallyDefined { // may be a struct non-pointer type
				toAppend = h.handleObject(structSpec, field, fieldType, locallyDefined, fieldPrefix)
			} else {
				toAppend = h.handleOther(structSpec, field, fieldType, locallyDefined, fieldPrefix)
			}
		}

		steps = append(steps, toAppend...)
	}

	return steps
}

func (h *handler) handleSlice(
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
	prefix string,
) []templateStep {
	_, fieldTypeIsPointer := fieldType.(*types.Slice).Elem().Underlying().(*types.Pointer)

	steps := []templateStep{
		{
			template: mapOrSliceSetTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), h.packageName),
			},
		},
		{
			template: sliceAppendTemplate,
			data: mutateFunctionData{
				TypeName:           structSpec.Name.Name,
				FieldName:          field.Names[0].Name,
				FieldTypeName:      trimAllPrefixes(fieldType.String(), h.packageName),
				FieldTypeIsPointer: fieldTypeIsPointer,
			},
		},
	}

	if !locallyDefined {
		return steps
	}

	return append(steps, templateStep{
		template: mutateSliceElementTemplate,
		data: mutateFunctionData{
			TypeName:           structSpec.Name.Name,
			FieldName:          field.Names[0].Name,
			FieldTypeName:      trimAllPrefixes(fieldType.String(), h.packageName),
			FieldTypeIsPointer: fieldTypeIsPointer,
			Prefix:             prefix,
		},
	})
}

func (h *handler) handleMap(
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
	prefix string,
) []templateStep {
	_, fieldTypeIsPointer := fieldType.(*types.Map).Elem().Underlying().(*types.Pointer)

	fieldKeyType := fieldType.(*types.Map).Key()
	_, fieldKeyTypeIsPointer := fieldKeyType.Underlying().(*types.Pointer)

	steps := []templateStep{
		{
			template: mapOrSliceSetTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), h.packageName),
			},
		},
		{
			template: mapInsertTemplate,
			data: mutateFunctionData{
				TypeName:              structSpec.Name.Name,
				FieldName:             field.Names[0].Name,
				FieldKeyTypeName:      trimAllPrefixes(fieldKeyType.String(), h.packageName),
				FieldTypeName:         trimAllPrefixes(fieldType.String(), h.packageName),
				FieldTypeIsPointer:    fieldTypeIsPointer,
				FieldKeyTypeIsPointer: fieldKeyTypeIsPointer,
			},
		},
	}

	if !locallyDefined {
		return steps
	}

	return append(steps, templateStep{
		template: mutateMapElementTemplate,
		data: mutateFunctionData{
			TypeName:           structSpec.Name.Name,
			FieldName:          field.Names[0].Name,
			FieldKeyTypeName:   trimAllPrefixes(fieldKeyType.String(), h.packageName),
			FieldTypeName:      trimAllPrefixes(fieldType.String(), h.packageName),
			FieldTypeIsPointer: fieldTypeIsPointer,
			Prefix:             prefix,
		},
	})
}

func (h *handler) handlePointer(
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
	prefix string,
) []templateStep {
	steps := []templateStep{
		{
			template: mutateSetPtrTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), h.packageName),
			},
		},
	}

	if !locallyDefined {
		return steps
	}

	return append(steps, templateStep{
		template: mutatePtrTemplate,
		data: mutateFunctionData{
			TypeName:      structSpec.Name.Name,
			FieldName:     field.Names[0].Name,
			FieldTypeName: trimAllPrefixes(fieldType.String(), h.packageName),
			Prefix:        prefix,
		},
	})
}

func (h *handler) handleObject(
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
	prefix string,
) []templateStep {
	steps := []templateStep{
		{
			template: mutateSetObjTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), h.packageName),
			},
		},
	}

	if !locallyDefined {
		return steps
	}

	return append(steps, templateStep{
		template: mutateObjTemplate,
		data: mutateFunctionData{
			TypeName:      structSpec.Name.Name,
			FieldName:     field.Names[0].Name,
			FieldTypeName: trimAllPrefixes(fieldType.String(), h.packageName),
			Prefix:        prefix,
		},
	})
}

func (h *handler) handleOther(
	structSpec *ast.TypeSpec,
	field *ast.Field,
	fieldType types.Type,
	locallyDefined bool,
	prefix string,
) []templateStep {
	return []templateStep{
		{
			template: mutateFieldTemplate,
			data: mutateFunctionData{
				TypeName:      structSpec.Name.Name,
				FieldName:     field.Names[0].Name,
				FieldTypeName: trimPackagePrefix(fieldType.String(), h.packageName),
			},
		},
	}
}

func isSelectedFilename(file string, list []string) bool {
	for _, item := range list {
		itemPath, err := filepath.Abs(item)
		if err != nil {
			continue
		}

		filePath, err := filepath.Abs(file)
		if err != nil {
			continue
		}

		if filePath == itemPath {
			return true
		}
	}

	return false
}

func trimPackagePrefix(input, packageName string) string {
	pattern := `(^|\[|\*|\])` + packageName + `\.`

	regex := regexp.MustCompile(pattern)

	return regex.ReplaceAllString(input, "$1")
}

func trimAllPrefixes(typeName string, pkg string) string {
	start := strings.LastIndexAny(typeName, "[]*")
	if start == -1 {
		start = 0
	} else {
		start++
	}

	dot := strings.LastIndex(typeName, ".")
	if dot == -1 || dot <= start {
		return typeName[start:]
	}

	if typeName[start:dot] == pkg {
		return typeName[dot+1:]
	}

	return typeName
}
