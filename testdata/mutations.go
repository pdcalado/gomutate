// Code generated by gomutate; DO NOT EDIT.
package main

import (
	"fmt"
	"time"
	
)
// Change represents a mutation applied to an object.
type Change struct {
	Prefix    string          `json:"prefix,omitempty"`
	FieldName string          `json:"field_name,omitempty"`
	Operation ChangeOperation `json:"operation,omitempty"`
	OldValue  string          `json:"old_value,omitempty"`
	NewValue  string          `json:"new_value,omitempty"`
}

// ChangeOperation defines a type used for change operation enums.
type ChangeOperation string

const (
	ChangeOperationAdded   ChangeOperation = "Added"
	ChangeOperationRemoved ChangeOperation = "Removed"
	ChangeOperationUpdated ChangeOperation = "Updated"
	ChangeOperationSet     ChangeOperation = "Set"
	ChangeOperationClear   ChangeOperation = "Clear"
)

// ChangeFormatter defines an interface for formatting changes to human readable string.
type ChangeFormatter interface {
	Format(c *Change) string
}

// DefaultChangeFormatter provides basic change formatting functionality.
type DefaultChangeFormatter struct{}

// Format formats a change to a human readable string.
func (f *DefaultChangeFormatter) Format(c *Change) string {
	switch c.Operation {
	case ChangeOperationAdded:
		return fmt.Sprintf("%s%s %s: %s", c.Prefix, c.FieldName, c.Operation, c.NewValue)
	case ChangeOperationRemoved:
		return fmt.Sprintf("%s%s %s: %s", c.Prefix, c.FieldName, c.Operation, c.OldValue)
	case ChangeOperationUpdated:
		return fmt.Sprintf("%s%s %s: %s -> %s", c.Prefix, c.FieldName, c.Operation, c.OldValue, c.NewValue)
	case ChangeOperationSet:
		return fmt.Sprintf("%s%s %s: %s", c.Prefix, c.FieldName, c.Operation, c.NewValue)
	case ChangeOperationClear:
		return fmt.Sprintf("%s%s %s", c.Prefix, c.FieldName, c.Operation)
	}
	return ""
}

// DefaultChangeLogger provides basic change logging functionality.
type DefaultChangeLogger struct {
	prefix    string
	changes   []Change
	formatter ChangeFormatter
}

// NewDefaultChangeLogger creates a new instance of DefaultChangeLogger.
func NewDefaultChangeLogger(prefix string) *DefaultChangeLogger {
	return &DefaultChangeLogger{
		prefix:    prefix,
		formatter: &DefaultChangeFormatter{},
	}
}

// Append appends a change to the change logger.
func (c *DefaultChangeLogger) Append(change Change) {
	change.Prefix = c.prefix + change.Prefix
	c.changes = append(c.changes, change)
}

// ToString converts the change logger to a slice of human readable strings.
func (c *DefaultChangeLogger) ToString() (result []string) {
	for i := range c.changes {
		result = append(result, c.formatter.Format(&c.changes[i]))
	}
	return
}

// ChainedChangeLogger implements ChangeLogger interface using an inner change logger.
// Multiple change loggers are chained together by prepending prefixes.
type ChainedChangeLogger struct {
	prefix string
	inner  ChangeLogger
}

// NewChainedChangeLogger creates a new instance of ChainedChangeLogger.
func NewChainedChangeLogger(prefix string, inner ChangeLogger) *ChainedChangeLogger {
	return &ChainedChangeLogger{
		prefix: prefix,
		inner:  inner,
	}
}

// Append appends a change to the change logger.
func (c *ChainedChangeLogger) Append(change Change) {
	change.Prefix = c.prefix + change.Prefix
	c.inner.Append(change)
}

// ToString converts the change logger to a slice of human readable strings.
func (c *ChainedChangeLogger) ToString() []string {
	return c.inner.ToString()
}

// ChangeLogger defines an interface for logging changes.
type ChangeLogger interface {
	Append(change Change)
	ToString() []string
}

// MutatorAcme mutates the Acme object.
type MutatorAcme struct {
	inner   *Acme
	changes ChangeLogger
}

// NewMutatorAcme creates a new mutator for the Acme object.
func NewMutatorAcme(
	obj *Acme,
	options ...func(*MutatorAcme),
) *MutatorAcme {
	m := &MutatorAcme{
		inner:   obj,
		changes: NewDefaultChangeLogger(""),
	}

	for _, option := range options {
		option(m)
	}

	return m
}

// WithChangeLogger sets the change logger for the mutator.
func WithChangeLogger(changeLogger ChangeLogger) func(*MutatorAcme) {
	return func(m *MutatorAcme) {
		m.changes = changeLogger
	}
}

// FormatChanges returns the changes that were made to the object as strings
func (m *MutatorAcme) FormatChanges() []string {
	return m.changes.ToString()
}

type MutatorAddress struct {
	inner   *Address
	changes ChangeLogger
}

func NewMutatorAddress(obj *Address, changes ChangeLogger) *MutatorAddress {
	return &MutatorAddress{
		inner:   obj,
		changes: changes,
	}
}

type MutatorVat struct {
	inner   *Vat
	changes ChangeLogger
}

func NewMutatorVat(obj *Vat, changes ChangeLogger) *MutatorVat {
	return &MutatorVat{
		inner:   obj,
		changes: changes,
	}
}

type MutatorEmployee struct {
	inner   *Employee
	changes ChangeLogger
}

func NewMutatorEmployee(obj *Employee, changes ChangeLogger) *MutatorEmployee {
	return &MutatorEmployee{
		inner:   obj,
		changes: changes,
	}
}

type MutatorProject struct {
	inner   *Project
	changes ChangeLogger
}

func NewMutatorProject(obj *Project, changes ChangeLogger) *MutatorProject {
	return &MutatorProject{
		inner:   obj,
		changes: changes,
	}
}

// SetName mutates the Name of the Acme object
func (m *MutatorAcme) SetName(value string) bool {
	if m.inner.Name == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Name",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Name),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Name = value

	return true
}

// SetYearOfBirth mutates the YearOfBirth of the Acme object
func (m *MutatorAcme) SetYearOfBirth(value int) bool {
	if m.inner.YearOfBirth == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "YearOfBirth",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.YearOfBirth),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.YearOfBirth = value

	return true
}

// SetName mutates the Name of the Employee object
func (m *MutatorEmployee) SetName(value string) bool {
	if m.inner.Name == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Name",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Name),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Name = value

	return true
}

// SetPosition mutates the Position of the Employee object
func (m *MutatorEmployee) SetPosition(value string) bool {
	if m.inner.Position == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Position",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Position),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Position = value

	return true
}

// SetWage mutates the Wage of the Employee object
func (m *MutatorEmployee) SetWage(value int) bool {
	if m.inner.Wage == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Wage",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Wage),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Wage = value

	return true
}

// SetJoinedAt mutates the JoinedAt of the Employee object
func (m *MutatorEmployee) SetJoinedAt(value time.Time) bool {
	if m.inner.JoinedAt == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "JoinedAt",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.JoinedAt),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.JoinedAt = value

	return true
}

// SetName mutates the Name of the Project object
func (m *MutatorProject) SetName(value string) bool {
	if m.inner.Name == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Name",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Name),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Name = value

	return true
}

// SetValue mutates the Value of the Project object
func (m *MutatorProject) SetValue(value int) bool {
	if m.inner.Value == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Value",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Value),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Value = value

	return true
}

// SetStartedAt mutates the StartedAt of the Project object
func (m *MutatorProject) SetStartedAt(value time.Time) bool {
	if m.inner.StartedAt == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "StartedAt",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.StartedAt),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.StartedAt = value

	return true
}

// SetFinishedAt mutates the FinishedAt of the Project object
func (m *MutatorProject) SetFinishedAt(value time.Time) bool {
	if m.inner.FinishedAt == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "FinishedAt",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.FinishedAt),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.FinishedAt = value

	return true
}

// SetProjects sets Projects of the Employee object
func (m *MutatorEmployee) SetProjects(value []Project) bool {

	if len(value) == 0 && len(m.inner.Projects) == 0 {
		return false
	}

	operation := ChangeOperationSet
	if len(value) == 0 {
		operation = ChangeOperationClear
	}

	m.changes.Append(Change{
		FieldName: "Projects",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Projects),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Projects = value

	return true
}

// AppendProjects appends a Projects element of the Employee object.
func (m *MutatorEmployee) AppendProjects(value ...Project) {
	m.changes.Append(Change{
		FieldName: "Projects",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Projects = append(m.inner.Projects, value...)
}

// RemoveProjects removes a Projects element of the Employee object.
func (m *MutatorEmployee) RemoveProjects(index int) {
	m.changes.Append(Change{
		FieldName: "Projects",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.Projects[index]),
	})
	m.inner.Projects = append(m.inner.Projects[:index], m.inner.Projects[index+1:]...)
}

// ProjectsAt returns a mutator for Projects element at index of the Employee object.
func (m *MutatorEmployee) ProjectsAt(index int) *MutatorProject {
	return NewMutatorProject(&m.inner.Projects[index], NewChainedChangeLogger(fmt.Sprintf("Projects "), m.changes))
}


// SetEmployees sets Employees of the Acme object
func (m *MutatorAcme) SetEmployees(value []*Employee) bool {

	if len(value) == 0 && len(m.inner.Employees) == 0 {
		return false
	}

	operation := ChangeOperationSet
	if len(value) == 0 {
		operation = ChangeOperationClear
	}

	m.changes.Append(Change{
		FieldName: "Employees",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Employees),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Employees = value

	return true
}

// AppendEmployees appends a Employees element of the Acme object.
func (m *MutatorAcme) AppendEmployees(value ...*Employee) {
	m.changes.Append(Change{
		FieldName: "Employees",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Employees = append(m.inner.Employees, value...)
}

// RemoveEmployees removes a Employees element of the Acme object.
func (m *MutatorAcme) RemoveEmployees(index int) {
	m.changes.Append(Change{
		FieldName: "Employees",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.Employees[index]),
	})
	m.inner.Employees = append(m.inner.Employees[:index], m.inner.Employees[index+1:]...)
}

// EmployeesAt returns a mutator for Employees element at index of the Acme object.
func (m *MutatorAcme) EmployeesAt(index int) *MutatorEmployee {
	return NewMutatorEmployee(m.inner.Employees[index], NewChainedChangeLogger(fmt.Sprintf("Employees "), m.changes))
}

// EmployeesByPtr returns a mutator for Employees element given by a pointer of type Acme.
func (m *MutatorAcme) EmployeesByPtr(ptr *Employee) *MutatorEmployee {
	for i, item := range m.inner.Employees {
		if item == ptr {
			return m.EmployeesAt(i)
		}
	}
	return nil
}

// SetStreet mutates the Street of the Address object
func (m *MutatorAddress) SetStreet(value string) bool {
	if m.inner.Street == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Street",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Street),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Street = value

	return true
}

// SetNumber mutates the Number of the Address object
func (m *MutatorAddress) SetNumber(value int) bool {
	if m.inner.Number == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Number",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Number),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Number = value

	return true
}

// SetCity mutates the City of the Address object
func (m *MutatorAddress) SetCity(value string) bool {
	if m.inner.City == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "City",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.City),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.City = value

	return true
}

// SetZip mutates the Zip of the Address object
func (m *MutatorAddress) SetZip(value int) bool {
	if m.inner.Zip == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Zip",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Zip),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Zip = value

	return true
}

// SetLocation sets Location of the Address object
func (m *MutatorAddress) SetLocation(value *string) bool {

	if value == nil && m.inner.Location == nil {
		return false
	}

	if value == m.inner.Location {
		return false
	}

	operation := ChangeOperationClear
	valueStr := fmt.Sprintf("%+v", value)
	oldValueStr := fmt.Sprintf("%+v", m.inner.Location)

	if value != nil {
		operation = ChangeOperationSet
		valueStr = fmt.Sprintf("%+v", *value)
	}

	if m.inner.Location != nil {
		oldValueStr = fmt.Sprintf("%+v", *m.inner.Location)
	}

	m.changes.Append(Change{
		FieldName: "Location",
		Operation: operation,
		OldValue:  oldValueStr,
		NewValue:  valueStr,
	})
	m.inner.Location = value

	return true
}

// SetAddress sets Address of the Acme object
func (m *MutatorAcme) SetAddress(value *Address) bool {

	if value == nil && m.inner.Address == nil {
		return false
	}

	if value == m.inner.Address {
		return false
	}

	operation := ChangeOperationClear
	valueStr := fmt.Sprintf("%+v", value)
	oldValueStr := fmt.Sprintf("%+v", m.inner.Address)

	if value != nil {
		operation = ChangeOperationSet
		valueStr = fmt.Sprintf("%+v", *value)
	}

	if m.inner.Address != nil {
		oldValueStr = fmt.Sprintf("%+v", *m.inner.Address)
	}

	m.changes.Append(Change{
		FieldName: "Address",
		Operation: operation,
		OldValue:  oldValueStr,
		NewValue:  valueStr,
	})
	m.inner.Address = value

	return true
}

// Address returns a mutator for Address of the Acme object.
// If the field is nil, it will be initialized to a new Address object.
func (m *MutatorAcme) Address() *MutatorAddress {

	if m.inner.Address == nil {
		m.inner.Address = &Address{}
	}

	return NewMutatorAddress(m.inner.Address, NewChainedChangeLogger(fmt.Sprintf("Address "), m.changes))
}

// SetNumber mutates the Number of the Vat object
func (m *MutatorVat) SetNumber(value string) bool {
	if m.inner.Number == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Number",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Number),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Number = value

	return true
}

// SetType mutates the Type of the Vat object
func (m *MutatorVat) SetType(value string) bool {
	if m.inner.Type == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Type",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Type),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Type = value

	return true
}

// SetVat sets Vat of the Acme object
func (m *MutatorAcme) SetVat(value *Vat) bool {

	m.changes.Append(Change{
		FieldName: "Vat",
		Operation: ChangeOperationSet,
		OldValue:  fmt.Sprintf("%+v", m.inner.Vat),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Vat = *value

	return true
}

// Vat returns a mutator for Vat of the Acme object.
func (m *MutatorAcme) Vat() *MutatorVat {

	return NewMutatorVat(&m.inner.Vat, NewChainedChangeLogger("Vat ", m.changes))
}

// SetNicknames sets Nicknames of the Acme object
func (m *MutatorAcme) SetNicknames(value map[string]*Employee) bool {

	if len(value) == 0 && len(m.inner.Nicknames) == 0 {
		return false
	}

	operation := ChangeOperationSet
	if len(value) == 0 {
		operation = ChangeOperationClear
	}

	m.changes.Append(Change{
		FieldName: "Nicknames",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Nicknames),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Nicknames = value

	return true
}

// InsertNicknames inserts a Nicknames map element of the Acme object.
func (m *MutatorAcme) InsertNicknames(
	key string,
	value *Employee,
) bool {
	currentValue, exists := m.inner.Nicknames[key]
	if exists && currentValue == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Nicknames",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("with key '%+v' and value: %+v", key, value),
	})

	if m.inner.Nicknames == nil {
		m.inner.Nicknames = make(map[string]*Employee)
	}

	m.inner.Nicknames[key] = value

	return true
}

// RemoveNicknames removes a Nicknames map element of the Acme object.
func (m *MutatorAcme) RemoveNicknames(key string) bool {
	_, exists := m.inner.Nicknames[key]
	if !exists {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Nicknames",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("with key '%+v' and value: %+v", key, m.inner.Nicknames[key]),
	})
	delete(m.inner.Nicknames, key)

	return true
}

// NicknamesWithKey returns a mutator for Nicknames map element Acme object with given key.
func (m *MutatorAcme) NicknamesWithKey(key string) *MutatorEmployee {
	return NewMutatorEmployee(
		m.inner.Nicknames[key],
		NewChainedChangeLogger(fmt.Sprintf("Nicknames "), m.changes),
	)
}

// SetEquity sets Equity of the Acme object
func (m *MutatorAcme) SetEquity(value map[*Employee]int) bool {

	if len(value) == 0 && len(m.inner.Equity) == 0 {
		return false
	}

	operation := ChangeOperationSet
	if len(value) == 0 {
		operation = ChangeOperationClear
	}

	m.changes.Append(Change{
		FieldName: "Equity",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Equity),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Equity = value

	return true
}

// InsertEquity inserts a Equity map element of the Acme object.
func (m *MutatorAcme) InsertEquity(
	key *Employee,
	value int,
) bool {
	currentValue, exists := m.inner.Equity[key]
	if exists && currentValue == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Equity",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("with key '%+v' and value: %+v", key, value),
	})

	if m.inner.Equity == nil {
		m.inner.Equity = make(map[*Employee]int)
	}

	m.inner.Equity[key] = value

	return true
}

// RemoveEquity removes a Equity map element of the Acme object.
func (m *MutatorAcme) RemoveEquity(key *Employee) bool {
	_, exists := m.inner.Equity[key]
	if !exists {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Equity",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("with key '%+v' and value: %+v", key, m.inner.Equity[key]),
	})
	delete(m.inner.Equity, key)

	return true
}
