// Code generated by gomutations; DO NOT EDIT.
package main

import (
	"fmt"
	"time"
	
)

type MutatorAcme struct {
	inner   *Acme
	changes ChangeLogger
}

func NewMutatorAcme(obj *Acme) *MutatorAcme {
	return &MutatorAcme{
		inner:   obj,
		changes: NewDefaultChangeLogger(""),
	}
}

// FormatChanges returns the changes that were made to the object as strings
func (m *MutatorAcme) FormatChanges() []string {
	return m.changes.ToString()
}

type MutatorAddress struct {
	inner   *Address
	changes ChangeLogger
}

func NewMutatorAddress(obj *Address, changes ChangeLogger) *MutatorAddress {
	return &MutatorAddress{
		inner:   obj,
		changes: changes,
	}
}

type MutatorVat struct {
	inner   *Vat
	changes ChangeLogger
}

func NewMutatorVat(obj *Vat, changes ChangeLogger) *MutatorVat {
	return &MutatorVat{
		inner:   obj,
		changes: changes,
	}
}

type MutatorEmployee struct {
	inner   *Employee
	changes ChangeLogger
}

func NewMutatorEmployee(obj *Employee, changes ChangeLogger) *MutatorEmployee {
	return &MutatorEmployee{
		inner:   obj,
		changes: changes,
	}
}

type MutatorProject struct {
	inner   *Project
	changes ChangeLogger
}

func NewMutatorProject(obj *Project, changes ChangeLogger) *MutatorProject {
	return &MutatorProject{
		inner:   obj,
		changes: changes,
	}
}

// MutateName mutates the Name of the Acme object
func (m *MutatorAcme) MutateName(value string) bool {
	if m.inner.Name == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Name",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Name),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Name = value

	return true
}

// MutateYearOfBirth mutates the YearOfBirth of the Acme object
func (m *MutatorAcme) MutateYearOfBirth(value int) bool {
	if m.inner.YearOfBirth == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "YearOfBirth",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.YearOfBirth),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.YearOfBirth = value

	return true
}

// MutateName mutates the Name of the Employee object
func (m *MutatorEmployee) MutateName(value string) bool {
	if m.inner.Name == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Name",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Name),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Name = value

	return true
}

// MutatePosition mutates the Position of the Employee object
func (m *MutatorEmployee) MutatePosition(value string) bool {
	if m.inner.Position == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Position",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Position),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Position = value

	return true
}

// MutateWage mutates the Wage of the Employee object
func (m *MutatorEmployee) MutateWage(value int) bool {
	if m.inner.Wage == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Wage",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Wage),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Wage = value

	return true
}

// MutateJoinedAt mutates the JoinedAt of the Employee object
func (m *MutatorEmployee) MutateJoinedAt(value time.Time) bool {
	if m.inner.JoinedAt == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "JoinedAt",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.JoinedAt),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.JoinedAt = value

	return true
}

// MutateName mutates the Name of the Project object
func (m *MutatorProject) MutateName(value string) bool {
	if m.inner.Name == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Name",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Name),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Name = value

	return true
}

// MutateValue mutates the Value of the Project object
func (m *MutatorProject) MutateValue(value int) bool {
	if m.inner.Value == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Value",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Value),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Value = value

	return true
}

// MutateStartedAt mutates the StartedAt of the Project object
func (m *MutatorProject) MutateStartedAt(value time.Time) bool {
	if m.inner.StartedAt == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "StartedAt",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.StartedAt),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.StartedAt = value

	return true
}

// MutateFinishedAt mutates the FinishedAt of the Project object
func (m *MutatorProject) MutateFinishedAt(value time.Time) bool {
	if m.inner.FinishedAt == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "FinishedAt",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.FinishedAt),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.FinishedAt = value

	return true
}

// SetProjects sets Projects of the Employee object
func (m *MutatorEmployee) SetProjects(value []Project) bool {

	if len(value) == 0 && len(m.inner.Projects) == 0 {
		return false
	}

	operation := ChangeOperationSet
	if len(value) == 0 {
		operation = ChangeOperationClear
	}

	m.changes.Append(Change{
		FieldName: "Projects",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Projects),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Projects = value

	return true
}

// AppendProjects appends a Projects element of the Employee object.
func (m *MutatorEmployee) AppendProjects(value ...Project) {
	m.changes.Append(Change{
		FieldName: "Projects",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Projects = append(m.inner.Projects, value...)
}

// RemoveProjects removes a Projects element of the Employee object.
func (m *MutatorEmployee) RemoveProjects(index int) {
	m.changes.Append(Change{
		FieldName: "Projects",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.Projects[index]),
	})
	m.inner.Projects = append(m.inner.Projects[:index], m.inner.Projects[index+1:]...)
}

// MutateProjectsAt returns a mutator for Projects element at index of the Employee object.
func (m *MutatorEmployee) MutateProjectsAt(index int) *MutatorProject {
	return NewMutatorProject(&m.inner.Projects[index], NewChainedChangeLogger(fmt.Sprintf("Projects "), m.changes))
}

// SetEmployees sets Employees of the Acme object
func (m *MutatorAcme) SetEmployees(value []*Employee) bool {

	if len(value) == 0 && len(m.inner.Employees) == 0 {
		return false
	}

	operation := ChangeOperationSet
	if len(value) == 0 {
		operation = ChangeOperationClear
	}

	m.changes.Append(Change{
		FieldName: "Employees",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Employees),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Employees = value

	return true
}

// AppendEmployees appends a Employees element of the Acme object.
func (m *MutatorAcme) AppendEmployees(value ...*Employee) {
	m.changes.Append(Change{
		FieldName: "Employees",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Employees = append(m.inner.Employees, value...)
}

// RemoveEmployees removes a Employees element of the Acme object.
func (m *MutatorAcme) RemoveEmployees(index int) {
	m.changes.Append(Change{
		FieldName: "Employees",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.Employees[index]),
	})
	m.inner.Employees = append(m.inner.Employees[:index], m.inner.Employees[index+1:]...)
}

// MutateEmployeesAt returns a mutator for Employees element at index of the Acme object.
func (m *MutatorAcme) MutateEmployeesAt(index int) *MutatorEmployee {
	return NewMutatorEmployee(m.inner.Employees[index], NewChainedChangeLogger(fmt.Sprintf("Employees "), m.changes))
}

// MutateStreet mutates the Street of the Address object
func (m *MutatorAddress) MutateStreet(value string) bool {
	if m.inner.Street == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Street",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Street),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Street = value

	return true
}

// MutateNumber mutates the Number of the Address object
func (m *MutatorAddress) MutateNumber(value int) bool {
	if m.inner.Number == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Number",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Number),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Number = value

	return true
}

// MutateCity mutates the City of the Address object
func (m *MutatorAddress) MutateCity(value string) bool {
	if m.inner.City == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "City",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.City),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.City = value

	return true
}

// MutateZip mutates the Zip of the Address object
func (m *MutatorAddress) MutateZip(value int) bool {
	if m.inner.Zip == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Zip",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Zip),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Zip = value

	return true
}

// SetLocation sets Location of the Address object
func (m *MutatorAddress) SetLocation(value *string) bool {

	if value == nil && m.inner.Location == nil {
		return false
	}

	if value == m.inner.Location {
		return false
	}

	operation := ChangeOperationClear
	valueStr := fmt.Sprintf("%+v", value)
	oldValueStr := fmt.Sprintf("%+v", m.inner.Location)

	if value != nil {
		operation = ChangeOperationSet
		valueStr = fmt.Sprintf("%+v", *value)
	}

	if m.inner.Location != nil {
		oldValueStr = fmt.Sprintf("%+v", *m.inner.Location)
	}

	m.changes.Append(Change{
		FieldName: "Location",
		Operation: operation,
		OldValue:  oldValueStr,
		NewValue:  valueStr,
	})
	m.inner.Location = value

	return true
}

// SetAddress sets Address of the Acme object
func (m *MutatorAcme) SetAddress(value *Address) bool {

	if value == nil && m.inner.Address == nil {
		return false
	}

	if value == m.inner.Address {
		return false
	}

	operation := ChangeOperationClear
	valueStr := fmt.Sprintf("%+v", value)
	oldValueStr := fmt.Sprintf("%+v", m.inner.Address)

	if value != nil {
		operation = ChangeOperationSet
		valueStr = fmt.Sprintf("%+v", *value)
	}

	if m.inner.Address != nil {
		oldValueStr = fmt.Sprintf("%+v", *m.inner.Address)
	}

	m.changes.Append(Change{
		FieldName: "Address",
		Operation: operation,
		OldValue:  oldValueStr,
		NewValue:  valueStr,
	})
	m.inner.Address = value

	return true
}

// MutateAddress returns a mutator for Address of the Acme object.
// If the field is nil, it will be initialized to a new Address object.
func (m *MutatorAcme) MutateAddress() *MutatorAddress {

	if m.inner.Address == nil {
		m.inner.Address = &Address{}
	}

	return NewMutatorAddress(m.inner.Address, NewChainedChangeLogger(fmt.Sprintf("Address "), m.changes))
}

// MutateNumber mutates the Number of the Vat object
func (m *MutatorVat) MutateNumber(value string) bool {
	if m.inner.Number == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Number",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Number),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Number = value

	return true
}

// MutateType mutates the Type of the Vat object
func (m *MutatorVat) MutateType(value string) bool {
	if m.inner.Type == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Type",
		Operation: ChangeOperationUpdated,
		OldValue:  fmt.Sprintf("%+v", m.inner.Type),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Type = value

	return true
}

// SetVat sets Vat of the Acme object
func (m *MutatorAcme) SetVat(value *Vat) bool {

	m.changes.Append(Change{
		FieldName: "Vat",
		Operation: ChangeOperationSet,
		OldValue:  fmt.Sprintf("%+v", m.inner.Vat),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Vat = *value

	return true
}

// MutateVat returns a mutator for Vat of the Acme object.
func (m *MutatorAcme) MutateVat() *MutatorVat {

	return NewMutatorVat(&m.inner.Vat, NewChainedChangeLogger("Vat ", m.changes))
}

// SetNicknames sets Nicknames of the Acme object
func (m *MutatorAcme) SetNicknames(value map[string]*Employee) bool {

	if len(value) == 0 && len(m.inner.Nicknames) == 0 {
		return false
	}

	operation := ChangeOperationSet
	if len(value) == 0 {
		operation = ChangeOperationClear
	}

	m.changes.Append(Change{
		FieldName: "Nicknames",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Nicknames),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Nicknames = value

	return true
}

// InsertNicknames inserts a Nicknames map element of the Acme object.
func (m *MutatorAcme) InsertNicknames(
	key string,
	value *Employee,
) bool {
	currentValue, exists := m.inner.Nicknames[key]
	if exists && currentValue == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Nicknames",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("with key '%+v' and value: %+v", key, value),
	})

	if m.inner.Nicknames == nil {
		m.inner.Nicknames = make(map[string]*Employee)
	}

	m.inner.Nicknames[key] = value

	return true
}

// RemoveNicknames removes a Nicknames map element of the Acme object.
func (m *MutatorAcme) RemoveNicknames(key string) bool {
	_, exists := m.inner.Nicknames[key]
	if !exists {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Nicknames",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.Nicknames[key]),
	})
	delete(m.inner.Nicknames, key)

	return true
}

// MutateNicknamesWithKey returns a mutator for Nicknames map element Acme object with given key.
func (m *MutatorAcme) MutateNicknamesWithKey(key string) *MutatorEmployee {
	return NewMutatorEmployee(
		m.inner.Nicknames[key],
		NewChainedChangeLogger(fmt.Sprintf("Nicknames "), m.changes),
	)
}

// SetEquity sets Equity of the Acme object
func (m *MutatorAcme) SetEquity(value map[*Employee]int) bool {

	if len(value) == 0 && len(m.inner.Equity) == 0 {
		return false
	}

	operation := ChangeOperationSet
	if len(value) == 0 {
		operation = ChangeOperationClear
	}

	m.changes.Append(Change{
		FieldName: "Equity",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Equity),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Equity = value

	return true
}

// InsertEquity inserts a Equity map element of the Acme object.
func (m *MutatorAcme) InsertEquity(
	key *Employee,
	value int,
) bool {
	currentValue, exists := m.inner.Equity[key]
	if exists && currentValue == value {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Equity",
		Operation: ChangeOperationAdded,
		NewValue:  fmt.Sprintf("with key '%+v' and value: %+v", key, value),
	})

	if m.inner.Equity == nil {
		m.inner.Equity = make(map[*Employee]int)
	}

	m.inner.Equity[key] = value

	return true
}

// RemoveEquity removes a Equity map element of the Acme object.
func (m *MutatorAcme) RemoveEquity(key *Employee) bool {
	_, exists := m.inner.Equity[key]
	if !exists {
		return false
	}

	m.changes.Append(Change{
		FieldName: "Equity",
		Operation: ChangeOperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.Equity[key]),
	})
	delete(m.inner.Equity, key)

	return true
}
