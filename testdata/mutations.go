// Code generated by gomutate; DO NOT EDIT.
package main

import (
	"fmt"
	"time"
	"reflect"
	"github.com/pdcalado/gomutate/changes"
	
)

// MutatorAcme mutates the Acme object.
type MutatorAcme struct {
	inner   *Acme
	changes changes.Logger
}

// NewMutatorAcme creates a new mutator for the Acme object.
func NewMutatorAcme(
	obj *Acme,
	options ...func(*MutatorAcme),
) *MutatorAcme {
	m := &MutatorAcme{
		inner:   obj,
		changes: changes.NewDefaultLogger(changes.PrefixEmpty),
	}

	for _, option := range options {
		option(m)
	}

	return m
}

// WithChangeLogger sets the change logger for the mutator.
func WithChangeLogger(logger changes.Logger) func(*MutatorAcme) {
	return func(m *MutatorAcme) {
		m.changes = logger
	}
}

// FormatChanges returns the changes that were made to the object as strings
func (m *MutatorAcme) FormatChanges() []string {
	return m.changes.ToString()
}

type MutatorAddress struct {
	inner   *Address
	changes changes.Logger
}

func NewMutatorAddress(obj *Address, changes changes.Logger) *MutatorAddress {
	return &MutatorAddress{
		inner:   obj,
		changes: changes,
	}
}

type MutatorVat struct {
	inner   *Vat
	changes changes.Logger
}

func NewMutatorVat(obj *Vat, changes changes.Logger) *MutatorVat {
	return &MutatorVat{
		inner:   obj,
		changes: changes,
	}
}

type MutatorEmployee struct {
	inner   *Employee
	changes changes.Logger
}

func NewMutatorEmployee(obj *Employee, changes changes.Logger) *MutatorEmployee {
	return &MutatorEmployee{
		inner:   obj,
		changes: changes,
	}
}

type MutatorProject struct {
	inner   *Project
	changes changes.Logger
}

func NewMutatorProject(obj *Project, changes changes.Logger) *MutatorProject {
	return &MutatorProject{
		inner:   obj,
		changes: changes,
	}
}


const (
	MutationPrefixAddress changes.FieldName = "Address"
	MutationPrefixEmployees changes.FieldName = "Employees"
	MutationPrefixEmployeesProjects changes.FieldName = "Projects"
	MutationPrefixNicknames changes.FieldName = "Nicknames"
	MutationPrefixVat changes.FieldName = "Vat"
)

// SetName mutates the Name of the Acme object
func (m *MutatorAcme) SetName(value string) bool {
	if m.inner.Name == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Name).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Name",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Name),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Name = value

	return true
}

// SetYearOfBirth mutates the YearOfBirth of the Acme object
func (m *MutatorAcme) SetYearOfBirth(value int) bool {
	if m.inner.YearOfBirth == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.YearOfBirth).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "YearOfBirth",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.YearOfBirth),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.YearOfBirth = value

	return true
}

// SetName mutates the Name of the Employee object
func (m *MutatorEmployee) SetName(value string) bool {
	if m.inner.Name == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Name).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Name",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Name),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Name = value

	return true
}

// SetPosition mutates the Position of the Employee object
func (m *MutatorEmployee) SetPosition(value string) bool {
	if m.inner.Position == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Position).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Position",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Position),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Position = value

	return true
}

// SetWage mutates the Wage of the Employee object
func (m *MutatorEmployee) SetWage(value int) bool {
	if m.inner.Wage == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Wage).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Wage",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Wage),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Wage = value

	return true
}

// SetJoinedAt mutates the JoinedAt of the Employee object
func (m *MutatorEmployee) SetJoinedAt(value time.Time) bool {
	if m.inner.JoinedAt == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.JoinedAt).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "JoinedAt",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.JoinedAt),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.JoinedAt = value

	return true
}

// SetName mutates the Name of the Project object
func (m *MutatorProject) SetName(value string) bool {
	if m.inner.Name == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Name).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Name",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Name),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Name = value

	return true
}

// SetValue mutates the Value of the Project object
func (m *MutatorProject) SetValue(value int) bool {
	if m.inner.Value == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Value).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Value",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Value),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Value = value

	return true
}

// SetStartedAt mutates the StartedAt of the Project object
func (m *MutatorProject) SetStartedAt(value time.Time) bool {
	if m.inner.StartedAt == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.StartedAt).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "StartedAt",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.StartedAt),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.StartedAt = value

	return true
}

// SetFinishedAt mutates the FinishedAt of the Project object
func (m *MutatorProject) SetFinishedAt(value time.Time) bool {
	if m.inner.FinishedAt == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.FinishedAt).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "FinishedAt",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.FinishedAt),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.FinishedAt = value

	return true
}

// SetProjects sets Projects of the Employee object
func (m *MutatorEmployee) SetProjects(value []Project) bool {

	if len(value) == 0 && len(m.inner.Projects) == 0 {
		return false
	}

	operation := changes.OperationSet
	if len(value) == 0 {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Projects",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Projects),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Projects = value

	return true
}

// AppendProjects appends a Projects element of the Employee object.
func (m *MutatorEmployee) AppendProjects(value ...Project) {
	m.changes.Append(changes.Change{
		FieldName: "Projects",
		Operation: changes.OperationAdded,
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Projects = append(m.inner.Projects, value...)
}

// RemoveProjects removes a Projects element of the Employee object.
func (m *MutatorEmployee) RemoveProjects(index int) {
	m.changes.Append(changes.Change{
		FieldName: "Projects",
		Operation: changes.OperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.Projects[index]),
	})
	m.inner.Projects = append(m.inner.Projects[:index], m.inner.Projects[index+1:]...)
}

// ProjectsAt returns a mutator for Projects element at index of the Employee object.
func (m *MutatorEmployee) ProjectsAt(index int) *MutatorProject {
	object := &m.inner.Projects[index]

	prefix := changes.NewPrefixWithKey(MutationPrefixEmployeesProjects, changes.IntoKey(object))

	return NewMutatorProject(
		object,
		changes.NewChainedLogger(prefix, m.changes),
	)
}


// SetEmployees sets Employees of the Acme object
func (m *MutatorAcme) SetEmployees(value []*Employee) bool {

	if len(value) == 0 && len(m.inner.Employees) == 0 {
		return false
	}

	operation := changes.OperationSet
	if len(value) == 0 {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Employees",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Employees),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Employees = value

	return true
}

// AppendEmployees appends a Employees element of the Acme object.
func (m *MutatorAcme) AppendEmployees(value ...*Employee) {
	m.changes.Append(changes.Change{
		FieldName: "Employees",
		Operation: changes.OperationAdded,
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Employees = append(m.inner.Employees, value...)
}

// RemoveEmployees removes a Employees element of the Acme object.
func (m *MutatorAcme) RemoveEmployees(index int) {
	m.changes.Append(changes.Change{
		FieldName: "Employees",
		Operation: changes.OperationRemoved,
		OldValue:  fmt.Sprintf("%+v", m.inner.Employees[index]),
	})
	m.inner.Employees = append(m.inner.Employees[:index], m.inner.Employees[index+1:]...)
}

// EmployeesAt returns a mutator for Employees element at index of the Acme object.
func (m *MutatorAcme) EmployeesAt(index int) *MutatorEmployee {
	object := m.inner.Employees[index]

	prefix := changes.NewPrefixWithKey(MutationPrefixEmployees, changes.IntoKey(object))

	return NewMutatorEmployee(
		object,
		changes.NewChainedLogger(prefix, m.changes),
	)
}

// EmployeesByPtr returns a mutator for Employees element given by a pointer of type Acme.
func (m *MutatorAcme) EmployeesByPtr(ptr *Employee) *MutatorEmployee {
	for i, item := range m.inner.Employees {
		if item == ptr {
			return m.EmployeesAt(i)
		}
	}
	return nil
}

// SetStreet mutates the Street of the Address object
func (m *MutatorAddress) SetStreet(value string) bool {
	if m.inner.Street == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Street).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Street",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Street),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Street = value

	return true
}

// SetNumber mutates the Number of the Address object
func (m *MutatorAddress) SetNumber(value int) bool {
	if m.inner.Number == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Number).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Number",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Number),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Number = value

	return true
}

// SetCity mutates the City of the Address object
func (m *MutatorAddress) SetCity(value string) bool {
	if m.inner.City == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.City).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "City",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.City),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.City = value

	return true
}

// SetZip mutates the Zip of the Address object
func (m *MutatorAddress) SetZip(value int) bool {
	if m.inner.Zip == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Zip).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Zip",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Zip),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Zip = value

	return true
}

// SetLocation sets Location of the Address object
func (m *MutatorAddress) SetLocation(value *string) bool {

	if value == nil && m.inner.Location == nil {
		return false
	}

	if value == m.inner.Location {
		return false
	}

	operation := changes.OperationCleared
	valueStr := fmt.Sprintf("%+v", value)
	oldValueStr := fmt.Sprintf("%+v", m.inner.Location)

	if value != nil {
		operation = changes.OperationSet
		valueStr = fmt.Sprintf("%+v", *value)
	}

	if m.inner.Location != nil {
		oldValueStr = fmt.Sprintf("%+v", *m.inner.Location)
	}

	m.changes.Append(changes.Change{
		FieldName: "Location",
		Operation: operation,
		OldValue:  oldValueStr,
		NewValue:  valueStr,
	})
	m.inner.Location = value

	return true
}

// SetAddress sets Address of the Acme object
func (m *MutatorAcme) SetAddress(value *Address) bool {

	if value == nil && m.inner.Address == nil {
		return false
	}

	if value == m.inner.Address {
		return false
	}

	operation := changes.OperationCleared
	valueStr := fmt.Sprintf("%+v", value)
	oldValueStr := fmt.Sprintf("%+v", m.inner.Address)

	if value != nil {
		operation = changes.OperationSet
		valueStr = fmt.Sprintf("%+v", *value)
	}

	if m.inner.Address != nil {
		oldValueStr = fmt.Sprintf("%+v", *m.inner.Address)
	}

	m.changes.Append(changes.Change{
		FieldName: "Address",
		Operation: operation,
		OldValue:  oldValueStr,
		NewValue:  valueStr,
	})
	m.inner.Address = value

	return true
}

// Address returns a mutator for Address of the Acme object.
// If the field is nil, it will be initialized to a new Address object.
func (m *MutatorAcme) Address() *MutatorAddress {

	if m.inner.Address == nil {
		m.inner.Address = &Address{}
	}

	prefix := changes.NewPrefix(MutationPrefixAddress)

	return NewMutatorAddress(m.inner.Address, changes.NewChainedLogger(prefix, m.changes))
}

// SetNumber mutates the Number of the Vat object
func (m *MutatorVat) SetNumber(value string) bool {
	if m.inner.Number == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Number).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Number",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Number),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Number = value

	return true
}

// SetType mutates the Type of the Vat object
func (m *MutatorVat) SetType(value string) bool {
	if m.inner.Type == value {
		return false
	}

	operation := changes.OperationUpdated
	if reflect.ValueOf(m.inner.Type).IsZero() {
		operation = changes.OperationSet
	} else if reflect.ValueOf(value).IsZero() {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Type",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Type),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Type = value

	return true
}

// SetVat sets Vat of the Acme object
func (m *MutatorAcme) SetVat(value *Vat) bool {

	m.changes.Append(changes.Change{
		FieldName: "Vat",
		Operation: changes.OperationSet,
		OldValue:  fmt.Sprintf("%+v", m.inner.Vat),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Vat = *value

	return true
}

// Vat returns a mutator for Vat of the Acme object.
func (m *MutatorAcme) Vat() *MutatorVat {
	prefix := changes.NewPrefix(MutationPrefixVat)
	return NewMutatorVat(&m.inner.Vat, changes.NewChainedLogger(prefix, m.changes))
}

// SetNicknames sets Nicknames of the Acme object
func (m *MutatorAcme) SetNicknames(value map[string]*Employee) bool {

	if len(value) == 0 && len(m.inner.Nicknames) == 0 {
		return false
	}

	operation := changes.OperationSet
	if len(value) == 0 {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Nicknames",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Nicknames),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Nicknames = value

	return true
}

// InsertNicknames inserts a Nicknames map element of the Acme object.
func (m *MutatorAcme) InsertNicknames(
	key string,
	value *Employee,
) bool {
	currentValue, exists := m.inner.Nicknames[key]
	if exists && currentValue == value {
		return false
	}

	m.changes.Append(changes.Change{
		FieldName: "Nicknames",
		Operation: changes.OperationAdded,
		Key:       changes.IntoKey(key),
		NewValue:  fmt.Sprintf("%+v", value),
	})

	if m.inner.Nicknames == nil {
		m.inner.Nicknames = make(map[string]*Employee)
	}

	m.inner.Nicknames[key] = value

	return true
}

// RemoveNicknames removes a Nicknames map element of the Acme object.
func (m *MutatorAcme) RemoveNicknames(key string) bool {
	_, exists := m.inner.Nicknames[key]
	if !exists {
		return false
	}

	m.changes.Append(changes.Change{
		FieldName: "Nicknames",
		Operation: changes.OperationRemoved,
		Key:       changes.IntoKey(key),
		OldValue:  fmt.Sprintf("%+v", m.inner.Nicknames[key]),
	})
	delete(m.inner.Nicknames, key)

	return true
}

// NicknamesWithKey returns a mutator for Nicknames map element Acme object with given key.
func (m *MutatorAcme) NicknamesWithKey(key string) *MutatorEmployee {
	object := m.inner.Nicknames[key]

	prefix := changes.NewPrefixWithKey(MutationPrefixNicknames, changes.IntoKey(object))

	return NewMutatorEmployee(
		object,
		changes.NewChainedLogger(prefix, m.changes),
	)
}

// SetEquity sets Equity of the Acme object
func (m *MutatorAcme) SetEquity(value map[*Employee]int) bool {

	if len(value) == 0 && len(m.inner.Equity) == 0 {
		return false
	}

	operation := changes.OperationSet
	if len(value) == 0 {
		operation = changes.OperationCleared
	}

	m.changes.Append(changes.Change{
		FieldName: "Equity",
		Operation: operation,
		OldValue:  fmt.Sprintf("%+v", m.inner.Equity),
		NewValue:  fmt.Sprintf("%+v", value),
	})
	m.inner.Equity = value

	return true
}

// InsertEquity inserts a Equity map element of the Acme object.
func (m *MutatorAcme) InsertEquity(
	key *Employee,
	value int,
) bool {
	currentValue, exists := m.inner.Equity[key]
	if exists && currentValue == value {
		return false
	}

	m.changes.Append(changes.Change{
		FieldName: "Equity",
		Operation: changes.OperationAdded,
		Key:       changes.IntoKey(key),
		NewValue:  fmt.Sprintf("%+v", value),
	})

	if m.inner.Equity == nil {
		m.inner.Equity = make(map[*Employee]int)
	}

	m.inner.Equity[key] = value

	return true
}

// RemoveEquity removes a Equity map element of the Acme object.
func (m *MutatorAcme) RemoveEquity(key *Employee) bool {
	_, exists := m.inner.Equity[key]
	if !exists {
		return false
	}

	m.changes.Append(changes.Change{
		FieldName: "Equity",
		Operation: changes.OperationRemoved,
		Key:       changes.IntoKey(key),
		OldValue:  fmt.Sprintf("%+v", m.inner.Equity[key]),
	})
	delete(m.inner.Equity, key)

	return true
}
